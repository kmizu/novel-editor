# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 重要な指示

**日本語で応答してください。**

**注意深く、用心深くコーディングをしてください。**

**問題が起きたときにパニックにならないでください。**

**作業を進める際は、以下の点を説明しながら実装してください：**

- なぜその技術・ライブラリを選択したのか
- 実装の手順と意図
- コードの構造とその理由
- テストの重要性と実装方法

**作業完了前の確認事項：**
各フェーズやタスクの完了を報告する前に、必ず以下を確認してください：

1. `npm run build` - ビルドが成功すること
2. `npm run type-check` - 型エラーがないこと
3. `npm run lint` - リントエラーがないこと
4. `npm run test` - 全てのテストが通ること
5. `npm run dev` - 開発サーバーが正常に起動すること

**重要：各ステップの作業が完了したら、必ずCLAUDE.mdのチェックボックスを [x] に更新してください。**

**自己改善しつつ、気付いたこと/気をつけるべきことなどをCLAUDE.mdに追記/修正していく**

## プロジェクト概要

ネット小説執筆支援エディタです。特にネット小説（カクヨム、小説家になろう等）の執筆をサポートするための多機能エディタで、プロット、キャラクター、世界観、各話ごとのメモなどを一元管理し、執筆プロセスをスムーズにします。React、TypeScript、Tailwind CSS、Viteを使用して開発されます。

## 主要機能（TODO）

- エディタ: 本文を執筆できるシンプルなエディタ
- プロット管理: 物語のプロットを管理・編集
- あらすじ管理: 物語のあらすじを管理・編集
- 各話メモ: 各話ごとの筆者メモを管理・編集
- キャラクター管理: 各登場人物のプロフィール、他キャラとの関係性を記録
- 世界観管理: 物語の舞台となる世界の歴史、地理、文化などの設定をまとめる
- 自動保存: 自動的にローカルストレージに保存
- エクスポート: プロジェクトをカクヨム形式、なろう形式としてエクスポート
- 新規プロジェクト: 複数のプロジェクトを切り替えて作業

## プロジェクトのセットアップ

プロジェクトは既に実装済みです。以下のコマンドで開始できます：

```bash
# 依存関係のインストール
npm install

# Web版として開発
npm run dev

# Electron版として開発（1つのコマンドで起動）
npm run dev:electron

# ビルド（Web版）
npm run build

# ビルド（Electron版）
npm run build:electron
```

### 開発コマンド一覧

```bash
# Web版として開発サーバーを起動
npm run dev

# Electron版として開発（Viteとelectronを同時起動）
npm run dev:electron

# ビルド（Web版）
npm run build

# ビルド（Electron版、実行可能ファイルを作成）
npm run build:electron

# プレビュー
npm run preview

# リント
npm run lint

# 型チェック
npm run type-check

# テスト実行
npm run test

# コードフォーマット
npm run format

# 全チェック実行
npm run check-all
```

## アーキテクチャ構造（推奨）

```
src/
├── components/     # 再利用可能なUIコンポーネント
├── features/       # 機能別のコンポーネント
│   ├── editor/
│   ├── plot/
│   ├── character/
│   └── worldbuilding/
├── hooks/          # カスタムフック
├── utils/          # ユーティリティ関数
├── types/          # TypeScript型定義
└── styles/         # グローバルスタイル
```

## 注意事項

- 日本語でのコミュニケーションを優先してください
- 小説執筆に特化した機能の実装を心がけてください
- ユーザビリティとパフォーマンスを重視してください
- **TypeScriptでは`any`型の使用を原則禁止してください。適切な型定義を行い、型安全性を保証してください**
- **package.jsonに`"type": "module"`を追加し、ESモジュールを使用しています**
- **新しいコンポーネントを作成する際は、必ずPrettierのフォーマットに準拠してください**
- **ファイルの最後には改行を含めてください（Prettierの設定により）**

## テスト戦略

### ユニットテスト

- **フレームワーク**: Vitest（Viteとの親和性が高い）
- **対象**: ユーティリティ関数、カスタムフック、純粋なコンポーネント
- **カバレッジ目標**: 80%以上

### 統合テスト

- **フレームワーク**: React Testing Library + Vitest
- **対象**: 機能単位でのコンポーネント統合、ユーザーインタラクション
- **重点項目**:
  - エディタの編集・保存機能
  - プロジェクト管理機能
  - データの永続化と復元

### E2Eテスト

- **フレームワーク**: Playwright
- **対象**: 主要なユーザーフロー
- **テストシナリオ**:
  - 新規プロジェクト作成から章の執筆まで
  - キャラクター・世界観設定の管理
  - エクスポート機能

### 開発ループでのテスト実行

1. **プレコミット**: リントと型チェック
2. **開発中**: ウォッチモードでユニットテスト自動実行
3. **プルリクエスト**: 全テストスイート実行
4. **デプロイ前**: E2Eテストを含む完全なテスト実行

## 気づいた点・実装時の注意事項

### バージョン管理機能の実装で学んだこと
- **型定義の重要性**: NodeJS.Timeoutなどの環境依存の型は、より汎用的な`ReturnType<typeof setTimeout>`を使用する
- **差分計算アルゴリズム**: 現在は簡易的な行単位の差分計算を実装。本番環境では、より高度なアルゴリズム（Myers差分アルゴリズムなど）の使用を検討すべき
- **ストレージ戦略**: バージョン履歴の保存にはサイズ制限があるため、古いバージョンの圧縮や外部ストレージへの移行を検討する必要がある
- **UIデザイン**: バージョン履歴の表示は、タイムライン形式とリスト形式の両方を提供することで、ユーザビリティが向上する

### 統計・分析機能の実装で学んだこと
- **ライブラリの互換性**: React 19との互換性問題により、Rechartsの代わりにCSSベースのシンプルなグラフ表示を実装
- **執筆セッション管理**: 執筆活動を自動的に追跡し、5分間操作がなければセッション終了とする設計
- **文体分析**: 日本語テキストの分析には、文字種別（漢字・ひらがな・カタカナ）の割合計算が有効
- **パフォーマンス**: 大量のテキストを分析する際は、useMemoを活用して再計算を最小限に抑える
- **空のインターフェース問題**: TypeScriptでは空のインターフェースを避け、型エイリアスを使用する

### 共同執筆機能の実装で学んだこと
- **データのエクスポート/インポート**: プロジェクトの共有は、完全なJSONデータとして実装し、新しいプロジェクトIDを生成することで衝突を回避
- **ファイル操作**: File APIを使用したファイルの読み込みと、Blobを使用したファイルのダウンロード機能の実装
- **エラーハンドリング**: JSONパースエラーや不正なデータ形式に対する適切なエラーメッセージの提供
- **UX設計**: クリップボードコピーとファイル保存の両方の方法を提供することで、ユーザーの利便性を向上

### プラグインシステムの実装で学んだこと
- **セキュリティ**: プラグインコードの実行にはサンドボックス環境が必要（現在は簡易版として実装）
- **プラグインAPI設計**: プラグインが必要とする機能を適切に抽象化し、権限システムで制御
- **イベントシステム**: プラグイン間の通信とフックの実装には、イベント駆動型のアーキテクチャが有効
- **型安全性**: unknownとタイプガードを使用して、プラグインとの通信における型安全性を確保
- **UI統合**: プラグイン管理UIは、インストール済み、マーケットプレイス、開発者向けの3つのタブで整理

### 音声入力・読み上げ機能の実装で学んだこと
- **Web Speech API**: 音声認識（SpeechRecognition）と音声合成（SpeechSynthesis）APIの活用
- **ブラウザ互換性**: ベンダープレフィックス（webkit）への対応と、APIサポートの確認
- **日本語対応**: 言語設定（ja-JP）と日本語音声の優先選択
- **UX設計**: 音声入力中の視覚的フィードバック（アニメーション、中間結果表示）
- **エラーハンドリング**: マイク権限、ネットワークエラーなど、各種エラーへの適切な対応
- **設定の永続化**: 読み上げ速度、ピッチ、音量などの設定をカスタマイズ可能に

### 執筆テンプレート機能の実装で学んだこと
- **テンプレート設計**: ジャンル別、カテゴリ別に整理された階層的なテンプレート構造
- **組み込みテンプレート**: 「英雄の旅」「異世界転生」など、定番の物語構造をテンプレート化
- **プロジェクト初期化**: テンプレート選択によるプロジェクトの初期値設定
- **拡張性**: カスタムテンプレートの作成・編集機能を想定した設計
- **UI/UX**: テンプレート選択画面でのフィルタリング、プレビュー機能
- **型安全性**: テンプレートの各要素に対する詳細な型定義により、実装時の安全性を確保

## 実装作業計画

### フェーズ1: プロジェクト基盤構築

- [x] Viteプロジェクトの初期化（React + TypeScript）
- [x] Tailwind CSSのセットアップ
- [x] ESLint、Prettierの設定
- [x] 基本的なディレクトリ構造の作成
- [x] package.jsonのスクリプト設定（dev, build, lint, type-check）
- [x] テスト環境のセットアップ（Vitest、React Testing Library、Playwright）

### フェーズ2: 基本UIとルーティング

- [x] React Routerの導入と設定
- [x] メインレイアウトコンポーネントの作成
- [x] ナビゲーションメニューの実装
- [x] 各機能のための基本的なページコンポーネント作成
- [x] 基本的なコンポーネントのユニットテスト作成

### フェーズ3: データモデルとストレージ

- [x] TypeScript型定義の作成（Project, Chapter, Character, Plot等）
- [x] ローカルストレージ管理のフックとユーティリティ
- [x] データの永続化とリストア機能
- [x] プロジェクト管理機能（新規作成、切り替え、削除）
- [x] ストレージ機能の統合テスト作成

### フェーズ4: エディタ機能

- [x] テキストエディタコンポーネントの実装
- [x] 自動保存機能
- [x] 文字数カウント機能
- [x] 章の管理（追加、編集、削除、並び替え）
- [x] エディタ機能のE2Eテスト作成

### フェーズ5: プロット・あらすじ管理

- [x] プロットエディタの実装
- [x] あらすじエディタの実装
- [x] 各話メモ機能の実装
- [x] プロットと本文の連携機能

### フェーズ6: キャラクター管理

- [x] キャラクター作成・編集フォーム
- [x] キャラクタープロフィール表示
- [x] キャラクター間の関係性マップ
- [x] キャラクター検索・フィルタリング

### フェーズ7: 世界観管理

- [x] 世界観設定の入力フォーム
- [x] カテゴリ別管理（地理、歴史、文化等）
- [x] 用語集機能
- [x] 設定資料の検索機能

### フェーズ8: エクスポート機能

- [x] カクヨム形式でのエクスポート
- [x] なろう形式でのエクスポート
- [x] プレーンテキストエクスポート
- [x] バックアップ機能（JSON形式）

### フェーズ9: UI/UX改善

- [x] ダークモード対応
- [x] レスポンシブデザインの最適化
- [x] キーボードショートカット
- [x] アクセシビリティ改善

### フェーズ10: パフォーマンス最適化と品質向上

- [x] コンポーネントの最適化（メモ化等）
- [x] 大規模プロジェクトでのパフォーマンステスト
- [x] テストカバレッジ80%以上の達成
- [x] CI/CDパイプラインの設定
- [x] パフォーマンス監視の実装

### フェーズ11: 統計・分析機能

- [x] 執筆セッション追跡システムの実装
- [x] 日次/週次/月次の執筆統計
- [x] 文体分析機能（漢字率、頻出単語など）
- [x] キャラクター登場頻度分析
- [x] プロジェクト進捗ダッシュボード
- [x] 統計データのエクスポート機能（JSON/CSV）
- [x] 執筆時間帯分析
- [x] グラフ表示（Recharts使用）

### フェーズ12: Electronアプリ化

- [x] Electron環境のセットアップ（electron, electron-builder等のインストール）
- [x] Electronメインプロセス（main.js）の作成
- [x] プリロードスクリプトの作成（セキュアなIPC通信）
- [x] ファイルシステムAPIの実装（保存・読み込み・エクスポート）
- [x] 既存のローカルストレージ保存をファイルシステム保存に移行
- [x] メニューバーの実装（ファイル操作、編集メニュー等）
- [x] 自動保存機能のファイルシステム対応
- [x] ビルド設定とパッケージング設定
- [x] 全機能の動作確認とテスト

### Electronアプリ化で学んだこと
- **ストレージ戦略の抽象化**: Web版とElectron版で異なるストレージ実装を持つため、StorageServiceインターフェースで抽象化
- **IPC通信のセキュリティ**: contextBridgeとpreloadスクリプトを使用して、セキュアなIPC通信を実装
- **型安全性の確保**: Electron APIの型定義を明確にし、anyの使用を最小限に抑える
- **プラットフォーム判定**: window.electronAPIの存在でElectron環境かWeb環境かを判定
- **ファイルシステムアクセス**: ローカルファイルへの直接的な読み書きが可能になり、.nepファイル形式でプロジェクトを保存
- **開発体験の向上**: concurrentlyとwait-onを使用して、1つのコマンドでViteとElectronを同時起動
- **electron-is-dev**: 開発環境と本番環境を自動判定し、適切な動作をする

### UI/UX改善で学んだこと (2025-01-19)
- **キーボードショートカット**: カスタムイベントを使用してコンポーネント間で通信
  - 検索（Ctrl+F）、置換（Ctrl+Shift+H）、章移動（Ctrl+↑/↓）などを追加
  - ショートカット一覧モーダル（Ctrl+?）を実装
- **レスポンシブデザイン**: モバイル対応のサイドバーとハンバーガーメニュー
  - サイドバーのスライドアニメーション
  - 画面幅に応じた自動調整
- **検索・置換機能**: 正規表現をエスケープして安全な検索を実現
  - 大文字・小文字の区別オプション
  - 一括置換と個別置換の選択肢
- **トースト通知**: コンテキストを使用したグローバルな通知システム
  - 成功、エラー、情報、警告の4種類
  - 自動消去タイマー付き
- **ローディング表示**: スピナー、スケルトンUI、フルページローディング
- **エラーバウンダリー**: Reactのクラスコンポーネントでエラーをキャッチ
- **自動バックアップ**: localStorageを使用した定期バックアップと復元機能
  - バックアップ間隔と保存数のカスタマイズ
  - 手動バックアップと復元機能
- **リッチテキストエディタ**: contentEditableとdocument.execCommandを使用
  - 太字、斜体、下線、取り消し線
  - リスト、引用、コードブロック
  - 元に戻す・やり直す機能
- **アクセシビリティ**: sr-onlyクラス、aria-label属性の追加

### Electron「名前を付けて保存」機能のデバッグ (2025-01-18)
- **問題**: メニューから「名前を付けて保存」を選択してもファイル保存ダイアログが開かない
- **調査内容**:
  - IPCイベントの流れ: main.js → preload.js → ElectronMenuHandler の流れは正常
  - activeProjectがnullの可能性を確認
  - useProjectsフックがローカルストレージベースの実装を使用していることを発見
- **デバッグ手法**:
  - 各段階でconsole.logを追加して、データの流れを追跡
  - activeProjectがない場合の代替案として、activeProjectIdから再取得する処理を追加
- **今後の改善点**:
  - useProjectsフックをElectron版でも動作するように修正が必要
  - プロジェクトデータの管理をStorageServiceで統一する必要がある

### 「名前を付けて保存」が本文を保存しない問題の修正 (2025-06-18)
- **根本原因**: 章データの保存と取得で異なるキーを使用していた
  - `useChapters`フック: `StorageKeys.CHAPTERS`（全プロジェクトの章を一つのキーに保存）
  - `storage.getChapters()`: `${STORAGE_PREFIX}chapters_${projectId}`（プロジェクトごとに別のキーで保存）
- **修正内容**:
  - `useChapters`フックを`storage.getChapters()`と`storage.saveChapters()`を使用するように変更
  - これにより、章データの保存と取得が一貫性のあるキーを使用するようになった
- **学んだこと**:
  - データの保存と取得で一貫性のあるキーを使用することの重要性
  - ストレージ関数を一元化して使用することで、このような問題を防ぐことができる
